---
title: '[Array] Leetcode 523번: Continuous Subarray Sum'
date: '2023-01-22'
lastmod: '2023-01-22'
tags: ['algorithm', 'array', 'leetcode']
draft: false
summary: '배열과 관련된 leetcode 523번 문제 입니다.'
---

![main](/static/leetcode/cover.jpg)

## 1.문제 설명

주어진 배안의 sub-배열의 요소가 2개 이상이고 요소들의 합이 k의 배수인 경우가 있다면 true 를 return, 아니면 false 를 return 하세요. 참고로 0또한 k의 배수로 간주합니다.

## 2. 문제 접근

이문제는 Subarray 을 파악하고 그 Subarray 안의 갯수가와 합이 조건은 만족해야 한다. 가장 이 문제를 빠르게 해결하는 방법은 O(n) 이다. 그 이상의 속도가 걸리는 방법 예를들면 O(n\*n) 과 같은 방법도 있는데, 그 방법은 하나의 숫자를 지정하고 그 숫자 이외의 연속되는 숫자를 모두 파악하기 때문에 속도가 매우느리다. 따라서 배열은 그냥 처음부터 마지막까지 순서대로 순회만 하는 알고리즘을 짜야 한다.

그러한 시간복잡도 조건을 만족하면서 원하는 결과를 얻으려면 어떻게 해야 할까. 이 문제의 핵심은 hashMap,remainder 그리고 index 를 이용하는 것이다. 문제에서 예시로 주어진 경우를 가지고 문제 접근 방법을 설명해보겠습니다.

- [23,2,4,6,7], k=6

우선 문제 조건에서 subarray 는 최소 2개 이상이라는 전제 조건을 걸고 있다. 그리고 합이 k의 배수관계 이어야 한다. k=6이기 때문에 다음과 같은 숫자들이 해당된다. 또한 문제 조건에서 0도 배수로 포함시킨다고 했다.

```tsx
0,6,12,18,24 ...
```

이제 subarray 를 찾기 위해 순회를 해보겠습니다.

```tsx

//i=0
23%6 = 5
```

나머지가 5가 나왔습니다. 나머지를 이용하여 subarray 를 찾는 방법은 다음과 같습니다. 우선 지금의 경우 나머지가 5가 나왔습니다. 이제 다음 iteration 을 돌리면서 숫자들을 계속 더해 줍니다. 그렇게 되면 23->25->29->... 와 같은 변화를 가지게 될것입니다. 그리고 더할때마다 k로 나누어 줍니다. 그때 나눈 나머지가 다시 5가 나온다면 결국 정확히 k만큼 더했을 때만 같은 나머지가 나올수 밖에 없다.

```tsx
// i=1
25%6 = 1

// i==2
29%6 = 5
```

주어진 예시의 경우에는 처음 23일떄 나머지가 5 그리고 i=2일때 29가 되고 나머지가 다시 5가 나온다. 29와 23의 차이는 정확히 6이며 6은 문제에서 주어진 k와 같은 값이된다. 따라서 subarray 가 존재한다고 말 할 수 있다.

그런데 만약 아래와 같은 경우가 생긴다면 어떨까?

- [23,6,4,6,7] k=6

또다른 예시를 이용해서 설명을 하자면 처음엔 23 그리고 그다음에는 29이다 나머지가 다시 5가 나오니 subarray 가 존재한다고 말할수 있을까? 그렇지 않다. 왜냐하면 문제의 조건을 보면 subarray 는 최소 2개이상의 요소로 구성된 배열이라고 했다. 즉 이경우는 [6] 인데 이건 1개뿐이라 해당되지 않는다. 그러면 이러한 경우를 어떻게 구분지을수 있을까? 바로 index 를 이용하는 것이다.

hashMap 을 만들고 그 안에 remainder 와 index 를 저장하고 나서 index 를 어떻게 사용하면 되는지 설명해보겠습니다. 계산은 이전의 예시였던 [23,2,4,6,7], k=6 로 하겠습니다.

| remainder | index |
| :-------: | :---: |
|  23%6=5   |   0   |
|  25%6=1   |   1   |
|  29%6=5   |   2   |

hashMap 은 중복을 허용하지 않습니다. 따라서 29%6=5 가 다시 나오는 시점에 index 간 차이를 구해주면된다. 그리고 그 차이는 2 이상이어야 한다. 왜냐하면 배열은 최소 2개이상의 요소를 가지고 있어야 하기 때문이다.

위의 경우에서도 [23,2,4] 이었고 23은 index는 0, 4의 index는 2이다. 둘의 차이는 2이고 실제로 sub-array 의 길이또한 이경우 2이다 [2,4]. 그렇기 때문에 Index 를 저장하고 둘의 차이를 계산하는 것이다.

마지막으로 더 고려해야 하는 것은 0이 존재하는 경우이다. [0] 은 subarray 가 아니지만 [0,0] 같은 경우는 sub-array 이다.

예를들어 아래과 같은 배열과 k 가 주어진다.

- [24,0,4,6,7] k=6

| remainder | index |
| :-------: | :---: |
|  24%6=0   |   0   |
|  24%6=0   |   1   |

첫번쨰 24는 합이 6의 배수이다. 그리고 두번쨰 24+0 또한 합이 6의 배수이다. 따라서 [24,0] 이라는 subarray 가 존재한다. 하지만 이전에 언급했던 로직으로 따져본다면 index 간 차이이기 때문에 1-0 은 1이되고 2보다 작다는 결과, 즉 길이가 1이라는 의미인데 사실 길이는 2이다. 이러한 edge case 를 제거하기 위해 처음에 hashMap 을 만들떄 initialize 해줘야 하는 부분이 있다.

```tsx
hash.set(0, -1)
```

이런식으로 설정해주면 이제 다음과 같은 결과가 나오게 된다.

| remainder | index |
| :-------: | :---: |
|     0     |  -1   |

은 이제 다음과 같이 바뀐다

| remainder | index |
| :-------: | :---: |
|  24%6=0   |  -1   |

그리고 마지막으로

| remainder |  index   |
| :-------: | :------: |
|  24%6=0   | 1-(-1)=2 |

가 된다. 즉 0인경우도 커버 할 수 있게 된 것이다.

## 3. 풀이

위에서 설명한 과정을 코드로 풀어보면 다음과 같다.

```tsx
var checkSubarraySum = function (nums, k) {
  let hash = new Map()
  let sum = 0

  hash.set(0, -1)

  for (let i = 0; i < nums.length; i++) {
    sum += nums[i]
    let rest = sum % k
    if (!hash.has(rest)) {
      hash.set(rest, i)
    } else if (i - hash.get(rest) >= 2) {
      return true
    }
  }
  return false
}
```

감사합니다.

#### reference:

- [Continuous Subarray Sum - Leetcode 523 - Python](https://www.youtube.com/watch?v=OKcrLfR-8mE)
- [LeetCode 523. Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/)
