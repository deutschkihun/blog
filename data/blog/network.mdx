---
title: '네트워크'
date: '2022-07-31'
lastmod: '2022-08-01'
tags: ['network']
draft: false
summary: '개발자가 알아야할 네트워크 기본지식.'
authors: ['default']
---

![main](/static/network/cover.jpg)

## 1. TCP vs UDP

### UDP

- 데이터를 데이터그램 단위로 처리하는 비연결형 프로토콜
- 낮은 신뢰성을 보장한다.
- TCPP보다 속도가 빠르다.

### TCP

- 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 연결형 프로토콜
- 높은 신뢰성을 보장한다.
- UDP보다 속도가 느리다.
- 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.

## 2. 브라우저에 url을 입력하면 무슨 일이 일어날까?

### step 1. url 을 해석합니다.

입력받은 url 을 scheme,host,port number 등등으로 분리해서 해석하고 필요한 정보들을 정리한다.

### step 2. DNS 조회를 통해 ip 주소로 변환한다.

이전단계에서 해석한 정보들을 이용해서 ip 주소로 변환해야 한다. 이때 만약 브라우저 캐시에 관련 정보가 있다면 ip 변환을 바로 진행 할 수 있다. 그렇지 않다면 hosts 파일을 참조한다. 관련 정보가 있다면 ip 변환을 바로 진행한다. 그렇지 않으면 마지막으로 dns 를 호출하게 된다. dns 는 domain name system 의 약자이며 dns 를 이용해서 해석한 url 을 ip 주소로 변환한다.

### step 3. 해당 ip가 존재하는 서버로 이동한다.

변환한 ip 주소를 이용해서 해당 서버로 이동한다.

### step 4. 서버로 이동하기 전 arp 를 이용해서 논리주소인 ip를 물리주소인 mac 주로소 변환한다.

서버로 이동 할 때 가지고 있는 ip 주소로는 바로 이동하는 것이 불가능하다. 그 이유는 ip 주소는 논리주소이기 때문이다. 논리주소라는 것은 예를 들면 경기도 화성시 동탄원천로 315-33 과 같은 것은 말한다. 즉 이주소만을 가지고서는 해당 지역으로 이동하는 것이 불가능하다. 만약 우리가 논리주소를 네비게이션에 입력하면 네이게이션은 그 주소에 해당하는 물리주소인 좌표로 변환하여 해당 주소의 위치를 안내해준다. 이러한 과정은 ip주소의 서버로 이동 할 때에도 필요하며 이러한 과정은 arp 을 이용해서 할 수 있다. arp 는 address resolution protocol 을 말하며 arp 를 이용해서 논리주소인 ip 주소를 물리주소인 mac 주소로 변환 시킬 수 있게 된다.

### step 5. tcp 통신을 통해 서버의 socket 을 연다.

이전과정에서 mac 주소로 변환된 주소를 이용해 서버에 접근해야 하는데 이때 tcp 통신을 통해 서버의 socket (프로그램의 endpoint) 을 열어야 합니다. 실제 socket 을 열어 approval (승인,허락) 을 받아야만 데이터를 전달 할 수 있습니다.
이때 tcp 연결을 허락받기 위해 3-way-handshake 가 실행됩니다. 이 과정을 비유하자면 택배의 물건 (클라이언트의 request / 데이터)을 고객(서버)에게 전달하기 위해 초인종(socket)을 누르는 것과 같다고 말 할 수 있다. 여기서 approval 이 된다면 데이터를 서버로 전달 할 수 있게 된다.

### step 6. 서버가 response 를 client 로 보낸다.

### step 7. response 정보를 이용해서 브라우저는 랜더링 작업을 한다.

## 3. HTTP vs HTTPS

### HTTP

- HTML과 같은 문서를 전송하기 위한 애플리케이션 프로토콜 (메시지 교환방식 체계).
- 비연결성
- 비상태성
- HTTP 는 평문 (암호화 되지 않은 데이터) 통신이기 때문에 보안에 취약

### HTTPS (HTTP Secure)

- HTTP + 데이터 암호화 기술(SSL)

### SSL 작동 방식

SSL은 **공개키 암호화 방식**을 이용해서 문서를 보안한다.이 방식의 핵심은 바로 공개키와 개인키가 있는 것인데,
공개키는 누구에게나 공개되어 "모두가 접근이 가능한 키"고 개인키는 딱 한 사람만이 소유해 "본인을 제외한 누구도 접근이 불가능한 키"다ß

## 4. GET VS POST

두 메소드 다 HTTP 프로토콜을 이용해서 서버에 무엇인가를 요청할 때 사용하는 방식이다. 하지만 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 알맞은 용도에 사용해야한다.

### **GET**

- GET 서버에서 어떤 데이터를 가져와서 보여주는 것 / 서버의 값이나 상태 등을 변경하지 않는다.
- 요청하는 데이터가 HTTP Request Message의 Header 부분에 url 이 담겨서 전송.
- url 상에 ? 뒤에 데이터가 붙어 request 를 보내게 되는 것이다. 이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다.
- 또한 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 GET방식은 적절하지 않다. (ex. password)

### **POST**

- POST 는 서버의 값이나 상태를 새롭게 저장 혹은 추가하기 위해서 사용된다
- POST 방식의 request 는 HTTP Request Message의 Body 부분에 데이터가 담겨서 전송된다.
- 데이터 크기가 GET 방식보다 크다.

## 5. PATCH VS PUT

둘은 공통적으로 특히 서버의 resource 을 수정(update)하는 용도로 사용한다.하지만 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 알맞은 용도에 사용해야한다.

### **PUT**

요청한 URI에 payload(ex. Request Body)에 있는 자원으로 **대체(replace)** 하는 메소드. 여기서 대체하는 메소드라는 것은 대상을 저장하기도, 변경한다는 것을 의미한다. 결국 PUT 메서드는 상황에 따라 다르게 동작하게 되는데 이를 두 가지 경우로 나눌수 있다.

- 요청한 URI 아래에 자원이 존재하지 않는 경우

  > 자원이 존재하지 않는 경우는 단순하다. POST와 마찬가지로 새로운 resource 로 저장하고 클라이언트에게 Http Status Code를 201(Created) 응답을 보내주면 된다.

- 요청한 URI 아래에 자원이 존재하는 경우자원이 존재하는 경우

  > payload에 담긴 정보를 이용해서 새로운 자원을 만들어 기존에 존재하던 자원을 대체한다.그리고 해당 요청이 잘 적용되었다는 것을 클라이언트에게 200(ok) 혹은 204(no content)를 이용해서 알려주면 된다. 대표적인 예시: 좋아요 / 싫어요 버튼 (binary, 기존 것을 대체 하면 된다.)

### **PATCH**

PATCH 요청은 자원에 대한 부분적인 수정을 적용하기 위한 HTTP 메서드이다.

> 대표적인 예시: 회원 정보 수정 (주소,전화번호,이름)

**그러면 회원 정보 수정 같은 예시에 put 을 사용해도 되지 않나?**

> 예를 들어 전화번호를 수정하고 확인 버튼을 누르게 되면 patch 의 경우는 해당 유저정보를 서버에서 찾아서 전화번호만 수정/업데이트 시켜주는데, put 을 하게 되면 기존에 있던것을 지워버리고 서버로 넘어온 데이터들로 대체를 하게 된다.

> 이경우에 만약 클라이언트가 수정된 전화번호만 넘겨주고 나머지 다른 기존의 유저 정보들을 넘겨주지 않는다면 서버에는 새롭게 변경된 전화번호만 들어가게 된다. 즉 기존의 정보들이 다 날아가게 된다는 것이다.

그래서 기본적으로 put 을 이용하려면 payload (request.body) 가 요구하는 모든 정보를 다 담고 있어야 put 이 patch 와 같은 기능을 수행 할 수 있게 되는 것이다.
또한 새롭게 대체하기 때문에 불필요한 서버 작업이 필요하기 때문에 **patch** 를 쓰는 것이 바람직하다.

## 6. Load Balancing

서버가 처리해야 할 업무 혹은 요청(Load)을 여러 대의 서버로 나누어(Balancing) 처리하는 것을 의미한다.

![main](/static/network/load-balancing.png)

## 7. 대칭키 암호화 vs 공개키 암호화

- 대칭키 암호화 방식은 **암복호화시 사용하는 키가 서로 동일한 경우이다.** 송신자가 키를 이용해서 암호화하여 보내면 수신자는 동일한 키로 복호화 해야한다.

![symmetric-key](/static/network/symmetric-key.png)

### 공개키

공개키는 암복호화시 **서로 사용하는 키가 다른 경우이고,** 송수신자는 공개키와 개인키 쌍을 가지고 있다.

암호화를 하는 방식은 크게 두가지로 나눌 수 있다.

- 수신자의 공개키로 암호화하여 보내는 경우 소량의 메세지를 암호화 하거나, 키 교환시 키를 암호화 하는데 주로 사용하는 방식

- 송신자의 개인키로 암호화하여 보내는 경우 송신자의 공개키만 있다면 열어볼 수 있으므로 인증이 주목적

감사합니다.

#### reference: [Interview_Question_for_Beginner](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network)
