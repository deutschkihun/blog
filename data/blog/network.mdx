---
title: '네트워크'
date: '2022-07-31'
lastmod: '2022-08-01'
tags: ['network']
draft: false
summary: '개발자가 알아야할 네트워크 기본지식.'
authors: ['default']
---

![main](/static/network/cover.jpg)

## 1. TCP와 UDP의 비교

### UDP

`UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)`는 **비연결형 프로토콜** 이다. IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다. `UDP`는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 **하지 않는다.** 이 모두가 사용자 프로세스의 몫이다. `UDP`가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다.

종종 클라이언트는 서버로 짧은 요청을 보내고, 짧은 응답을 기대한다. 만약 요청 또는 응답이 손실된다면, 클라이언트는 time out 되고 다시 시도할 수 있으면 된다. 코드가 간단할 뿐만 아니라 TCP 처럼 초기설정(initial setup)에서 요구되는 프로토콜보다 적은 메시지가 요구된다.

`UDP`를 사용한 것들에는 `DNS`가 있다. 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은, DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다. 사전에 설정이 필요하지 않으며 그 후에 해제가 필요하지 않다.

### TCP

대부분의 인터넷 응용 분야들은 **신뢰성** 과 **순차적인 전달** 을 필요로 한다. UDP 로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 `TCP`이다. `TCP(Transmission Control Protocol, 전송제어 프로토콜)`는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 **바이트 스트림을 전송** 하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. TCP 에서 연결 설정은 `3-way handshake`를 통해 행해진다.

### TCP 3-way Handshake

TCP 3 way handshake는 전송의 신뢰성을 보장하기 위해서 통신 이전에 세션을 수립하는 것이다. 양쪽 모두 통신 준비가 되었다는 것을 확인하는 과정이며, 서로의 일련번호를 얻을 수 있다.

1. `Client`가 접속을 요청하는 `SYN` 패킷을 보낸다.
   - `Client`는 `SYN_SENT` 상태가 되어 `SYN/ACK` 응답을 기다린다.
2. `Server`가 요청을 승인하는 `SYN/ACK` 패킷을 보낸다.
   - `Server`는 `SYN_RECEIVED`상태가 되어 `ACK`를 기다린다.
3. `Client`는 `ACK`를 보내고 이 후로부터는 연결이 이루어진다.
   - `Client`와 `Server`는 `ESTABLISHED` 상태가 된다.

![handshake](/static/network/handshake.png)

## 2. 브라우저에 url을 입력하면 무슨 일이 일어날까?

### step 1. url 을 해석합니다.

입력받은 url 을 scheme,host,port number 등등으로 분리해서 해석하고 필요한 정보들을 정리한다.

### step 2. DNS 조회를 통해 ip 주소로 변환한다.

이전단계에서 해석한 정보들을 이용해서 ip 주소로 변환해야 한다. 이때 만약 브라우저 캐시에 관련 정보가 있다면 ip 변환을 바로 진행 할 수 있다. 그렇지 않다면 hosts 파일을 참조한다. 관련 정보가 있다면 ip 변환을 바로 진행한다. 그렇지 않으면 마지막으로 dns 를 호출하게 된다. dns 는 domain name system 의 약자이며 dns 를 이용해서 해석한 url 을 ip 주소로 변환한다.

### step 3. 해당 ip가 존재하는 서버로 이동한다.

변환한 ip 주소를 이용해서 해당 서버로 이동한다.

### step 4. 서버로 이동하기 전 arp 를 이용해서 논리주소인 ip를 물리주소인 mac 주로소 변환한다.

서버로 이동 할 때 가지고 있는 ip 주소로는 바로 이동하는 것이 불가능하다. 그 이유는 ip 주소는 논리주소이기 때문이다. 논리주소라는 것은 예를 들면 경기도 화성시 동탄원천로 315-33 과 같은 것은 말한다. 즉 이주소만을 가지고서는 해당 지역으로 이동하는 것이 불가능하다. 만약 우리가 논리주소를 네비게이션에 입력하면 네이게이션은 그 주소에 해당하는 물리주소인 좌표로 변환하여 해당 주소의 위치를 안내해준다. 이러한 과정은 ip주소의 서버로 이동 할 때에도 필요하며 이러한 과정은 arp 을 이용해서 할 수 있다. arp 는 address resolution protocol 을 말하며 arp 를 이용해서 논리주소인 ip 주소를 물리주소인 mac 주소로 변환 시킬 수 있게 된다.

### step 5. tcp 통신을 통해 서버의 socket 을 연다.

이전과정에서 mac 주소로 변환된 주소를 이용해 서버에 접근해야 하는데 이때 tcp 통신을 통해 서버의 socket (프로그램의 endpoint) 을 열어야 합니다. 실제 socket 을 열어 approval (승인,허락) 을 받아야만 데이터를 전달 할 수 있습니다.
이때 tcp 연결을 허락받기 위해 3-way-handshake 가 실행됩니다. 이 과정을 비유하자면 택배의 물건 (클라이언트의 request / 데이터)을 고객(서버)에게 전달하기 위해 초인종(socket)을 누르는 것과 같다고 말 할 수 있다. 여기서 approval 이 된다면 데이터를 서버로 전달 할 수 있게 된다.

### step 6. 서버가 response 를 client 로 보낸다.

### step 7. response 정보를 이용해서 브라우저는 랜더링 작업을 한다.

## 3. HTTP vs HTTPS

HTTP: HTML과 같은 문서를 전송하기 위한 애플리케이션 프로토콜 (메시지 교환방식 체계).

### **HTTP** 구조

- HTTP는 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다.
- HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이
- Method, Path, Version, Headers, Body 등으로 구성된다.

### **HTTP** 단점

- HTTP로 비밀번호나 주민등록번호 등을 주고 받으면 제3자가 정보를 조회할 수 있다.
- HTTP 는 평문 (암호화 되지 않은 데이터) 통신이기 때문에 도청이 가능하다. 또한 통신 상대를 확인하지 않기 때문에 위장이 가능하다.

### **HTTPS**

- HTTP에 데이터 암호화가 추가된 프로토콜이다.(SSL)
- HTTPS는 HTTP와 다르게 443번 포트를 사용 + 암호화
- SSL + HTTP = HTTPS (HTTP Secure)

![http-https](/static/network/http-https.png)

모든 웹 페이지에서 HTTPS를 사용해도 될까?

- 평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구한다. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 request의 수가 상대적으로 줄어들게 된다. 하지만 기술의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 새로운 표준인 HTTP 2.0을 함께 이용한다면 오히려 HTTPS가 HTTP보다 더 빠르게 동작한다.

### SSL

SSL은 웹사이트와 브라우저 사이에서 전송되는 데이터를 암호화하여 인터넷 연결을 보호하기 위한 표준 기술이다.
이를 통해 개인 데이터나 금융데이터 등의 전송되는 정보를 보거나 훔치는 것을 방지한다.

### SSL 작동 방식

SSL은 **공개키 암호화 방식**을 이용해서 문서를 보안한다.이 방식의 핵심은 바로 공개키와 개인키가 있는 것인데,
공개키는 누구에게나 공개되어 "모두가 접근이 가능한 키"고 개인키는 딱 한 사람만이 소유해 "본인을 제외한 누구도 접근이 불가능한 키"다

### SSL 흐름

1. 서버는 공개키와 개인키를 만든다.

2. 믿을만한 저장소(CA)와 계약해 두 키를 관리하도록 한다.

3. CA도 자신만의 공개키와 개인키를 가지고 자체 암호화를 하여 SSL 인증서를 발급한다.

4. 클라이언트의 데이터 요청이 들어오면 서버는 CA에서 만든 SSL 인증서를 보내준다.

5. 클라이언트는 CA의 공개키를 이용해 SSL 인증서를 복호화(암호 해독)한다.

6. SSL 내부의 서버 공개키를 이용해서 암호화해서 인증서를 서버에게 보낸다.

7. 서버는 개인키로 암호화된 인증서를 복호화(암호 해독)하고 다시 암호화 하여 클라이언트에게 보낸다.

### TLS

TLS(전송 계층 보안)는 SSL의 발전된 버전이다. 즉, 인터넷 커뮤니케이션을 위한 개인 정보와 데이터 무결성을 제공하는 보안 프로토콜이다.

### TLS / SSL Handshake 과정

![http-https](/static/network/tsl-ssl-handshake.png)

1. `Client Hello` : Client가 Server에 연결을 시도하며 전송하는 패킷이다.

   - 사용 가능한 **암호화 알고리즘**, **세션 ID**, **SSL 프로토콜 버전**, **Random Byte**등 전달

2. `Server Hello` : Client가 보내온 `Client Hello` 패킷을 받고, 암호화 알고리즘을 선택해서 Clinet에게 알린다.

   - 자신의 SSL 프로토콜도 같이 보낸다.

3. `Certificate` : server가 `CA (인증기관)`의 개인키로 암호화된 자신의 SSL 인증서를 Client에게 전달한다.
   - 인증서 내부에 Server가 발행한 **공개키**가 들어있다.
   - Client는 `CA`의 공개키로 복호화한다. -> 성공하면 이 SSL인증서는 `CA`가 서명한 것 확인
4. `Server Key Exchange / ServerHello Done` : Server의 공개키가 SSL 인증서에 없는 경우, Server가 직접 전달한다. (있으면 생략) 그리고 Server가 행동을 마쳤음을 전달한다.

5. `Client Key Exchange` : 대칭키를 Client가 생성해서 위에서 얻은 Server의 공개키로 암호화해서 전달한다.

   - 여기서 전달한 **대칭키**가 `TLS/SSL Handshake`의 목적이다.
   - 이후 이 대칭키를 이용해서 데이터를 암호화하여 교환한다.

6. `ChangeCipherSpec / Finished` : 패킷으로 교환할 정보를 모두 교환한 뒤 통신할 준비가 완료되었다고 알린다.

## 4. GET VS POST

두 메소드 다 HTTP 프로토콜을 이용해서 서버에 무엇인가를 요청할 때 사용하는 방식이다. 하지만 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 알맞은 용도에 사용해야한다.

### **GET**

- GET 서버에서 어떤 데이터를 가져와서 보여주는 것 / 서버의 값이나 상태 등을 변경하지 않는다.
- 요청하는 데이터가 HTTP Request Message의 Header 부분에 url 이 담겨서 전송.
- url 상에 ? 뒤에 데이터가 붙어 request 를 보내게 되는 것이다. 이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다.
- 또한 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 GET방식은 적절하지 않다. (ex. password)

### **POST**

- POST 는 서버의 값이나 상태를 새롭게 저장 혹은 추가하기 위해서 사용된다
- POST 방식의 request 는 HTTP Request Message의 Body 부분에 데이터가 담겨서 전송된다.
- 데이터 크기가 GET 방식보다 크다.

## 5. PATCH VS PUT

둘은 공통적으로 특히 서버의 resource 을 수정(update)하는 용도로 사용한다.하지만 둘의 특징을 제대로 이해하여 기술의 목적에 맞게 알맞은 용도에 사용해야한다.

### **PUT**

요청한 URI에 payload(ex. Request Body)에 있는 자원으로 **대체(replace)** 하는 메소드. 여기서 대체하는 메소드라는 것은 대상을 저장하기도, 변경한다는 것을 의미한다. 결국 PUT 메서드는 상황에 따라 다르게 동작하게 되는데 이를 두 가지 경우로 나눌수 있다.

- 요청한 URI 아래에 자원이 존재하지 않는 경우

  > 자원이 존재하지 않는 경우는 단순하다. POST와 마찬가지로 새로운 resource 로 저장하고 클라이언트에게 Http Status Code를 201(Created) 응답을 보내주면 된다.

- 요청한 URI 아래에 자원이 존재하는 경우자원이 존재하는 경우

  > payload에 담긴 정보를 이용해서 새로운 자원을 만들어 기존에 존재하던 자원을 대체한다.그리고 해당 요청이 잘 적용되었다는 것을 클라이언트에게 200(ok) 혹은 204(no content)를 이용해서 알려주면 된다. 대표적인 예시: 좋아요 / 싫어요 버튼 (binary, 기존 것을 대체 하면 된다.)

### **PATCH**

PATCH 요청은 자원에 대한 부분적인 수정을 적용하기 위한 HTTP 메서드이다.

> 대표적인 예시: 회원 정보 수정 (주소,전화번호,이름)

**그러면 회원 정보 수정 같은 예시에 put 을 사용해도 되지 않나?**

> 예를 들어 전화번호를 수정하고 확인 버튼을 누르게 되면 patch 의 경우는 해당 유저정보를 서버에서 찾아서 전화번호만 수정/업데이트 시켜주는데, put 을 하게 되면 기존에 있던것을 지워버리고 서버로 넘어온 데이터들로 대체를 하게 된다.

> 이경우에 만약 클라이언트가 수정된 전화번호만 넘겨주고 나머지 다른 기존의 유저 정보들을 넘겨주지 않는다면 서버에는 새롭게 변경된 전화번호만 들어가게 된다. 즉 기존의 정보들이 다 날아가게 된다는 것이다.

그래서 기본적으로 put 을 이용하려면 payload (request.body) 가 요구하는 모든 정보를 다 담고 있어야 put 이 patch 와 같은 기능을 수행 할 수 있게 되는 것이다.
또한 새롭게 대체하기 때문에 불필요한 서버 작업이 필요하기 때문에 **patch** 를 쓰는 것이 바람직하다.

## 6. Load Balancing

서버가 처리해야 할 업무 혹은 요청(Load)을 여러 대의 서버로 나누어(Balancing) 처리하는 것을 의미한다.
한 대의 서버로 부하가 집중되지 않도록 트래픽을 관리해 각각의 서버가 최적의 퍼포먼스를 보일 수 있도록 하는 것이 목적이다.

![main](/static/network/load-balancing.png)

서비스의 규모가 커지고, 이용자 수가 늘어나면 기존의 서버만으로는 원활한 서비스 동작이 불가능하게 되고, 이에 대처할 수 있는 방법은 크게 두 가지로 나뉜다.

- 기존의 서버 성능을 확장하는 Scale-up 방식
- 기존의 서버와 동일하거나 낮은 성능의 서버를 증설하는 Scale-out 방식. 이때 Scale-out 방식을 통해 증가한 트래픽에 대처하기로 했다면, 여러 대의 서버로 트래픽을 균등하게 분산해주는 **로드 밸런싱**이 반드시 필요하다.

## 7. 대칭키 vs 공개키

두 방식은 네크워크 상에서 어떤 메세지를 보내거나 받을 때 사용하는 대표적인 두가지 암호화 방식이다.
우선 대칭키와 공개키를 이해하기 위한 기본적은 용어들이다.

- 기밀성 : 자원의 노출을 방지
- 무결성 : 자원의 변경을 방지
- 인증 : 그 사람이 보낸것인지?
- 부인방지 : 자원을 보내거나 받았을 때 부인을 방지

### 대칭키

대칭키 암호화 방식은 **암복호화시 사용하는 키가 서로 동일한 경우이다.**
송신자가 키를 이용해서 암호화하여 보내면 수신자는 동일한 키로 복호화 해야한다.

![symmetric-key](/static/network/symmetric-key.png)

### 공개키

공개키는 암복호화시 **서로 사용하는 키가 다른 경우이고,** 송수신자 모두 공개키와 개인키 쌍을 가지고 있다.
공개키는 말그대로 모두에게 공개되어 있는 키이고, 개인키는 본인만이 알고있고, 가지고 있는 키이다.

암호화를 하는 방식은 크게 두가지로 나눌 수 있다.

- 수신자의 공개키로 암호화하여 보내는 경우
  소량의 메세지를 암호화 하거나, 키 교환시 키를 암호화 하는데 주로 사용하는 방식이다.

- 송신자의 개인키로 암호화하여 보내는 경우
  송신자의 공개키만 있다면 열어볼 수 있으므로 인증과 부인방지가 목적이다. ( 전자 서명의 기초 )

## DNS round robin

### DNS Round Robin 방식의 문제점

1. 서버의 수 만큼 공인 IP 주소가 필요함 부하 분산을 위해 서버의 대수를 늘리기 위해서는 그 만큼의 공인 IP 가 필요하다.

2. 균등하게 분산되지 않음 모바일 사이트 등에서 문제가 될 수 있는데, 스마트폰의 접속은 캐리어 게이트웨이 라고 하는 프록시 서버를 경유 한다. 프록시 서버에서는 이름변환 결과가 일정 시간 동안 캐싱되므로 같은 프록시 서버를 경유 하는 접속은 항상 같은 서버로 접속된다. 또한 PC 용 웹 브라우저도 DNS 질의 결과를 캐싱하기 때문에 균등하게 부하분산 되지 않는다. DNS 레코드의 TTL 값을 짧게 설정함으로써 어느 정도 해소가 되지만, TTL 에 따라 캐시를 해제하는 것은 아니므로 반드시 주의가 필요하다.

3. 서버가 다운되도 확인 불가 DNS 서버는 웹 서버의 부하나 접속 수 등의 상황에 따라 질의결과를 제어할 수 없다. 웹 서버의 부하가 높아서 응답이 느려지거나 접속수가 꽉 차서 접속을 처리할 수 없는 상황인 지를 전혀 감지할 수가 없기 때문에 어떤 원인으로 다운되더라도 이를 검출하지 못하고 유저들에게 제공한다. 이때문에 유저들은 간혹 다운된 서버로 연결이 되기도 한다. DNS 라운드 로빈은 어디까지나 부하분산 을 위한 방법이지 다중화 방법은 아니므로 다른 S/W 와 조합해서 관리할 필요가 있다.

### Weighted round robin (WRR)

각각의 웹 서버에 가중치를 가미해서 분산 비율을 변경한다. 물론 가중치가 큰 서버일수록 빈번하게 선택되므로 처리능력이 높은 서버는 가중치를 높게 설정하는 것이 좋다.

### Least connection

접속 클라이언트 수가 가장 적은 서버를 선택한다. 로드밸런서에서 실시간으로 connection 수를 관리하거나 각 서버에서 주기적으로 알려주는 것이 필요하다.

감사합니다.

#### reference: [Interview_Question_for_Beginner](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network)
