---
title: '[Array] LeetCode 200번: Number of Islands'
date: '2023-01-22'
lastmod: '2023-01-22'
tags: ['algorithm', 'recursion', 'leetcode', 'dfs']
draft: false
summary: 'recursion 그리고 dfs 관련된 leetcode 200번 문제 입니다.'
---

![main](/static/leetcode/cover.jpg)

## 1.문제 설명

2차원 배열이 주어진다. 1과 0으로 구성되어 있다. 0으로 둘러싸인 1덩어리를 하나의 섬이라고 부른다. 이때 섬의 갯수는 몇개인가.

## 2. 문제 접근

일단 1을 먼저 찾는 것이 중요하다. 그리고 1을 찾았다면 1 동서남북으로 1이 존재하는지 확인해야 한다. 1이 존재한다면 그곳으로 재귀적으로 이동하여 다시 1이 있는 곳까지 찾는다. 그리고 1을 찾을 때마다 그 부분을 0으로 처리하여 다시 방문하지 않게 해야 한다.

dfs 에서 가장 중요한 로직중에 하나는 한번 방문한 노드는 다시 방문하지 않는 것이다.

## 3. 풀이

뒤에서 루프를 돌리면 다음과 같이 구현 해볼수 있다.

```tsx
var numIslands = function(grid) {
  let count = 0;
  let m = grid.length
  let n = grid[0].length

  for(let i=0; i<m; i<++) {
    for(let j=0; j<n; j++) {
      if(grid[i][j] === '1') {
        dfs(i,j)
        count++
      }
    }
  }

  function dfs(i,j) {
    if(grid[i][j] === 1) {
      grid[i][j] = 0
      if(i-1>=0) dfs(i-1,j)
      if(i+1<m)  dfs(i+1,j)
      if(j-1>=0) dfs(i,j-1)
      if(j+1<n)  dfs(i,j+1)
    }
  }
  return count
};
```

감사합니다.

#### reference: [leetcode 1460. Make Two Arrays Equal by Reversing Subarrays](https://leetcode.com/problems/make-two-arrays-equal-by-reversing-subarrays)
