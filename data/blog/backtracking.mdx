---
title: '[Algorithm] Backtracking'
date: '2023-01-22'
lastmod: '2023-01-22'
tags: ['algorithm', 'backtracking']
draft: false
summary: '백트래킹을 통해 모든 경우의 수를 탐색하는 알고리즘에 대해 알아보자.'
---

![main](/static/backtracking/cover.jpg)

백트래킹을 통해 모든 경우의 수를 탐색하는 알고리즘에 대해 알아보자.

## 1.Backtracking

- 모든 경우의 수를 탐색하는 알고리즘

- DFS 혹은 BFS 를 활용 할 수 있다

- 효율적인 탐색을 위해 탐색을 하지 않아도 되는 곳을 미리 막는 것을 가지치기 (prunning) 이라고 한다.

- 자바스크립트는 재귀 효율이 나쁘기 때문에 DFS를 구현할 경우 스택을 이용하는 것이 좋다

- 탐색에서 순환(cycle) 이 발생 할 수 있다면 BFS를 이용하는 것도 좋다.

## 2.키포인트

- 우선 모든 경우의 수를 찾을 수 있도록 코딩

- 이후 문제에서 특정한 조건을 만족하는 것만 탐색하고 나머지는 탐색하지 않도록 조건문을 작성한다

- 즉, 절대로 답이 될 수 없는 것은 탐색을 종료한다.

감사합니다.

## 3. 예시: leetcode 39(Combination sum)

문제 설명은 다음과 같다. 유니크한 element 로 구성된 배열과 target 이 주어진다. 여기서 찾아야 할 것은 배열에 구성된 element 의 합이 target 이 되는 모든 경우의 수를 찾아야한다. 추가적인 조건으로 element 를 중복해서 사용해도 된다는 것이다.

예를 들어 [2,5,6] 이라는 배열이 있고 target = 12 라고 가정해보자

그렇다면

```tsx
[2] — not enough (2)
[2, 2] — not enough (4)
[2, 2, 2] — not enough (6)
[2, 2, 2, 2] — not enough (8)
[2, 2, 2, 2, 2] — not enough (10)
[2, 2, 2, 2, 2, 2] — bingo! (12)
```

원하는 결과를 얻게 되었다. 이제 그다음의 경우도 생각해보자

```tsx
[2, 2, 2, 2, 5] — too much(15)
[2, 2, 2, 2, 6] — too much(16)
```

taregt 보다 큰 수들이기 때문에 더이상 해보는 것은 의미가 없다. 백트래킹에서는 brute forece 처럼 모든 경우의 수를 찾지만 그중에서 답이 될 확률이 없는 것은 가지치기를 하면서 로직을 작성해야 한다. 따라서 마지막 숫자가 3이상인 경우는 prunning 의 대상이된다.

이러한 방식으로 모든 경우의 수를 따져보면 다음과 같다.

```tsx

[ 2 ]
[ 2, 2 ]
[ 2, 2, 2 ]
[ 2, 2, 2, 2 ]
[ 2, 2, 2, 2, 2 ]
[ 2, 2, 2, 2, 2, 2 ] — success!
[ 2, 2, 2, 5 ]
[ 2, 2, 2, 6 ] — success!
[ 2, 2, 5 ]
[ 2, 2, 6 ]
[ 2, 5 ]
[ 2, 5, 5 ] — success!
[ 2, 6 ]
[ 5 ]
[ 5, 5 ]
[ 5, 6 ]
[ 6 ]
[ 6, 6 ] — success!

```

따라서 따져봐야 하는 경우의 수는 총 18개가 된다. 이는 prunning 을 하지 않았을 때의 경우의 수인 3의 3승 = 27보다 적은 경우의 수를 얻게 된다.

```tsx
function combinationSum(candidates, target) {
  let combi = []
  candidates.sort((a, b) => a - b)

  function backtracking(temp, remaining, start) {
    for (let i = start; i < candidates.length && candidates[i] <= remaining; i++) {
      if (candidates[i] === remaining) {
        combi.push([...temp, candidates[i]])
      } else {
        console.log(i)
        backtracking([...temp, candidates[i]], remaining - candidates[i], i)
      }
    }
  }
  backtracking([], target, 0)
  return combi
}
```

위의 코드를 좀더 쉽게 이해가 위해서 단계별로 어떻게 작동하는지 확인보겠습니다.

```tsx
backtracking([], 12, 0)
backtracking([2], 10, 0)
backtracking([2,2], 8, 0)
backtracking([2,2,2], 6, 0)
backtracking([2,2,2,2], 4, 0)
backtracking([2,2,2,2,2], 2, 0) -> combi.push([...[2,2,2,2,2],2])

그다음에는 backtracking([2,2,2,2,2], 2, 1) 그리고 i=1 이 된다.
그런데 이 시점에서 candidates[i] 는 5>remaining=2, 따라서 loop 가 중단된다. 그리고 이전에 종료되지 않은 루프로 다시 회귀 하게 된다.

backtracking([2,2,2,2], 4, 1) 그리고 i=1 이 된다. i=0 는 이전에 같은 backtracking 에서 처리됨.
이 부분역시 5>remaining=4 이어서 이전 루프로 회귀

backtracking([2,2,2], 5, 1)
backtracking([2,2,2], 6, 1) -> combi.push([...[2,2,,2],6])

이러한 방식으로 가능한 경우의 수를 탐색하게 된다.

```

#### reference: [[JavaScript] continue, break, return 차이](https://lpla.tistory.com/182)
