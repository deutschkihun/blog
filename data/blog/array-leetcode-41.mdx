---
title: '[Array] LeetCode 41번: First Missing Positive'
date: '2023-01-22'
lastmod: '2023-01-22'
tags: ['algorithm', 'array', 'leetcode']
draft: false
summary: '배열과 관련된 leetcode 41번 문제 입니다.'
---

![main](/static/leetcode/cover.jpg)

## 1.문제 설명

배열안에 들어가 있는 자연수중에 빠진 숫자중 가장 작은 수를 구하시오. time complexity O(n), space complexity 는 O(1) 을 사용합니다.

## 2. 문제 접근

space complexity 가 O(1) 이기 때문에 hash 를 사용하는 것을 추천합니다. 일반 배열은 사용하는게 불가능 하기 떄문에 hash 를 이용해서 배열안에 들어있는 값들을 확인하고, 1부터 시작하여 없는 값을 쭉 찾아나가면 time complexity 도 맞춰서 작업 하는 것이 가능할 것이라 생각됩니다.

## 3. 풀이

```tsx

var firstMissingPositive = function(nums) {
  if(!nums.length) return 1
  let hash = new Map()

  for (let num of nums) {
    if(num>0) hash.set(num,true)
  }

  let missing = 1

  for(missing, missing<=nums.length; i++) {
    if(!hash.get(missing)) return missing
  }
  return missing
}

```

감사합니다.

#### reference: [leetcode 1460. Make Two Arrays Equal by Reversing Subarrays](https://leetcode.com/problems/make-two-arrays-equal-by-reversing-subarrays)
