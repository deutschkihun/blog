---
title: 'Micro-frontend'
date: '2022-01-28'
lastmod: '2022-01-28'
tags: ['micro-frontend']
draft: false
summary: '마이크로프론트엔드는 마이크로 서비스처럼 기능 단위로 나누어 개발한 후에 합치는 방식입니다. 이 포스팅을 통해 마이크로프론트엔드에 대해 이해하고 공부하는 시간이 되었으면 좋겠습니다.'
---

![main](/static/microfrontend/cover.jpg)

## Micro-frontend 란?

마이크로프론트엔드는 마이크로 서비스처럼 기능 단위로 나누어 개발한 후에 합치는 방식입니다. 마이크로프론트엔드를 하나의 그림으로 표현하자만 다음과 같다.

![compare](/static/microfrontend/microfrontend.png)

조금더 자세히 설명하자면 마이크로 프론트엔드란 결국 프론트엔드에서 개별 팀이 담당하는 비즈니스 영역을 모듈화하여 완전히 구분하는 것을 말한다. 한 앱의 각각 일부 앱만 담당하는 것이 아니라, 각 팀 내에서 데이터베이스에서부터 사용자 인터페이스에 이르기까지 end-to-end를 완료하는 것이다.

마이크로 프론트엔드를 구성하는 방법에는 서버 템플릿 통합, 빌드타임 통합, iframe를 통한 런타임 통합, JS를 통한 런타임 통합, Web Components를 통한 런타임 통합 방식이 있다.

모놀리식의 단점
부분장애가 모든 서비스로 전파
기술스택의 종속
코드가 복잡해져 서비스 개선이 힘듬
Micro-Frontend를 사용한 이유
부분장애가 모든서비스로 전파되지않음
자유로운 기술스택
코드의 복잡성 제거
서비스 추가의 자유로움

모노레포란?
모노레포는 두 개 이상의 프로젝트 코드를 하나의 레포지토리에서 관리하는 기법입니다.

왜 모노레포를 사용하게 되었는가?
Micro-Frontend를 도입하면 기능별로 프로젝트를 분리할 필요가 있었습니다. 하지만 기능별로 git repository를 생성하게 된다면 CI/CD나 환경 변수 관리 등 모든 부분에서 관리가 힘들어질 수밖에 없습니다. 이런 문제를 해결하기 위해 Yarn Bery와 workspace-since 플러그인을 통해 모노레포를 구현하게 되었습니다.

## Micro-frontend 의 도입배경

모노리스 아키텍쳐
기존의 개발 방식으로, 각각의 기능들을 개발한 후 하나의 앱으로 패키징하여 배포하는 것을 말한다. 일반적으로 하나의 레포지토리 내에 하나의 큰 앱만 존재하여, 코드 공유가 쉽고 형식 통일과 배포 관리에 용이하다는 장점이 있다.

여러 팀으로 구성되는 대규모 프로젝트에서 문제가 될 수 있다. 예를 들어 계정/상품 확인/장바고니/배송/결제 기능이 포함된 인터넷 쇼핑몰에서, 결제 기능을 개발하기 위해 로그인 개발이 먼저 완료되어야 하는 등 개발 병목현상이 발생한다. 결제 시스템에서 문제가 생기더라도 상품 확인 및 장바구니를 포함한 모든 기능을 사용하지 못하게 되는 에러 확산이 발생하기도 한다.

전체 서비스가 하나의 프레임워크와 언어에 제한되는 경우도 생긴다. (사실 이 예시는 어떻게든 연결하는 레이어를 담으면 되는게 아닌가 싶기는 하지만.. https://wooaoe.tistory.com/57 요기 블로그 왈) 블록체인 모듈은 nodeJS를 일반적으로 사용하는데, 서버를 스프링을 통해 서비스를 시작하는 경우 이를 통해 연동해야 한다. 또한 수정하지 않은 다른 기능들을 포함한 전체 서비스 빌드가 필요하고, 작은 변경에도 높은 테스트 비용이 발생한다.

토스는 8~9명으로 구성된 사일로가 하나의 기능 개발을 담당한다고 한다. 각 사일로마다 개별적인 서비스를 구현하기 때문에 21년 세미나 당시 25개 이상의 리액트 서비스가 존재했다. 새로운 프로젝트는 자연스럽게 기존에 존재하던 프로젝트에 추가되는 형태로, 각 서비스는 웹팩의 엔트리포인트로 구분되기는 하지만, 하나의 패키지에서 하나의 웹팩설정으로 한번에 빌드되는 구조였다.

이로 인해 의존성 지옥과 너무 긴 빌드타임이라는 문제점이 발생했다.
서로 코드를 공유하지 않는 A와 B 서비스, 그리고 두 서비스가 공유하는 X라는 의존성 패키지가 존재한다고 하자. A는 이미 개발이 완료되어 정상적으로 서비스되던 중 B를 개발하다 보니 (이미 A에서 사용하던) X 패키지에서 버그 발견하게 되었다. 이때 B의 개발을 위해 X의 버전을 올리면 A에서 에러가 발생하거나 작동이 달라지는 경우가 종종 발생했다

또한 (앞에서 말했던 모노리스의 문제점..) A 서비스에서만 변경이 있다고 하더라도 변경이 없는 B부터 Z 서비스를 모두 새로 빌드해야 했으며, 사진에서와 같이 개발 도중에도 20분에서 40분간 빌드를 돌리고 멍하니 기다려야 하는 병목현상이 두드러지기 시작했다.
토스는 이를 해결하기 위해 기존의 거대한 소스코드를 독립적인 패키지로 분리하고 각각을 빌드하기로 결정하였는데, 레포지토리를 구분해서 사용하자니,,, 공통 코드의 공유 어려움, 사용 라이브러리의 파편화, 복잡한 서비스 관리 등의 문제가 발생하여 결국 모노레포를 도입하게 되었다.

#### reference

- [@kylexid/마이크로프론트엔드-아키텍쳐](https://velog.io/@kylexid/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90)

- [@dalbodre_ari/마이크로-프론트엔드와-모노레포-제로빌드](https://velog.io/@dalbodre_ari/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%99%80-%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC-%EC%A0%9C%EB%A1%9C%EB%B9%8C%EB%93%9C)

- [@eungyeole/Micro-Frontends-구축기-1](https://velog.io/@eungyeole/Micro-Frontends-%EA%B5%AC%EC%B6%95%EA%B8%B0-1)

- [토스ㅣSLASH 21 - Micro-frontend React, 점진적으로 도입하기](https://www.youtube.com/watch?v=DHPeeEvDbdo)
