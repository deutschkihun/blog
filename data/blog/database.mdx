---
title: '[Database] 데이터베이스'
date: '2023-01-20'
lastmod: '2023-01-20'
tags: ['database', 'sql', 'nosql']
draft: false
summary: 'software engineer 라면 반드시 알아야 할 데이터베이스 기초 지식 포스팅'
authors: ['default']
---

![main](/static/database/cover.jpg)

software engineer 라면 반드시 알아야 할 데이터베이스 기초 지식 포스팅

## 1.데이터베이스의 성능

데이터베이스의 성능 이슈는 디스크 I/O (input/output) 를 어떻게 줄이느냐에서 시작된다. 디스크 I/O 란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다. 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다. **즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정된다고 볼 수 있다.**

그렇기 때문에 순차 I/O 가 랜덤 I/O 보다 빠를 수 밖에 없다. 하지만 현실에서는 대부분의 I/O 작업이 랜덤 I/O 이다. **랜덤 I/O 를 순차 I/O 로 바꿔서 실행할 수는 없을까? 이러한 생각에서부터 시작되는 데이터베이스 쿼리 튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있다.**

## 2.Index

- DB에서 Index는 Table에 어떤 데이터가 어디에 위치하였는지 위치 정보를 가진 주소록의 개념을 가진다.
- Table의 컬럼을 색인화하여 풀스캔 하는 것이 아니라 색인화 되어있는 Index 파일을 검색하여 속도를 빠르게 하는 도구이다.
- Index는 Tree 구조로 색인화를 진행한다. (MySQL에서는 B+Tree 사용) B+-Tree 인덱스 알고리즘은 칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리한다.), 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- DBMS 의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다.
- **DBMS 에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.** SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.

### Index를 사용하면 좋은 경우

- 규모가 작지 않은 테이블

- INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼

- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼

- 데이터의 중복도가 낮은 컬럼

### Index를 지양해야 하는 경우

- 데이터의 중복도가 높은 열은 인덱스로 만들어도 효용이 없다. (성별같이 타입이 binary 인 경우)

## 3.정규화(Normalization)

- 하나의 Relation이 여러 entity의 attribute들을 혼합하게 되면 정보가 중복 저장되며,공간 낭비 발생.
- 복된 정보로 인해 갱신 이상이 발생하게 된다. 동일한 정보를 한 릴레이션에는 변경하고, 나머지 릴레이션에서는 변경하지 않은 경우 어느 것이 정확한지 알 수 없게 되는 것이다.
- 이러한 문제를 해결하기 위해 정규화 과정을 거친다.

### 제 1 정규형 (1NF): 하나의 칸에는 하나의 데이터만 보관하게 하자!

아래와 같은 테이블이 있다.
| 회원번호 | 회원이름 | 프로그램 |  
| :------: | :----: | :----: |
| 101 | 강호동 | 스쿼시초급 |  
| 102 | 손흥민 | 헬스 |  
| 103 | 김민수 | 헬스 |

103번 김민수가 골프초급 프로그램을 수강하려면 어떻게 표현할 수 있을까?
| 회원번호 | 회원이름 | 프로그램 |  
| :------: | :----: | :----: |
| 101 | 강호동 | 스쿼시초급 |  
| 102 | 손흥민 | 헬스 |  
| 103 | 김민수 | 헬스, 골프초급 |

위와 같이 프로그램 속성에 여러 값들로 표현할 수 있다. 하지만..

- 골프초급 수강신청한 사람들을 찾으려면 문자열 파싱을 통해 찾아야한다.
- 또한 프로그램명 수정도 쉽지 않다

### 제 1 정규형의 활용

| 회원번호 | 회원이름 |  프로그램  |
| :------: | :------: | :--------: |
|   101    |  강호동  | 스쿼시초급 |
|   102    |  손흥민  |    헬스    |
|   103    |  김민수  |    헬스    |
|   103    |  김민수  |  골프초급  |

- 각 컬럼이 하나의 값(속성)만을 가져야 한다.
- 하나의 컬럼은 같은 종류나 타입(type)의 값을 가져야 한다.
- 각 컬럼이 유일한(unique) 이름을 가져야 한다.
- 칼럼의 순서가 상관 없어야 한다.

### 제 2 정규형 (2NF): partial dependency(부분적 종속)를 제거한 테이블

| 회원번호 | 회원이름 |  프로그램  | 가격 | 납부여부 |
| :------: | :------: | :--------: | :--: | :------: |
|   101    |  강호동  | 스쿼시초급 | 5000 |    0     |
|   102    |  손흥민  |    헬스    | 6000 |    1     |
|   103    |  김민수  |    헬스    | 6000 |    1     |
|   103    |  김민수  |  골프초급  | 8000 |    0     |

헬스 요금을 7000원으로 인상하려면?

- 모든 Row를 뒤져가며 헬스의 가격을 7000원으로 인상해줘야해.
- 가격 하나 수정하는데 작업해야할게 너무 많다. 매우 비효율적

### 제 2 정규형을 활용

- 제 1 정규화까지 만족하는 상태
- 현제 테이블의 주제와 관련 없는 컬럼을 다른 테이블로 빼는 작업

| 회원번호 | 회원이름 |  프로그램  | 납부여부 |
| :------: | :------: | :--------: | :------: |
|   101    |  강호동  | 스쿼시초급 |    0     |
|   102    |  손흥민  |    헬스    |    1     |
|   103    |  김민수  |    헬스    |    1     |
|   103    |  김민수  |  골프초급  |    0     |

|  프로그램  | 가격 |
| :--------: | :--: |
| 스쿼시초급 | 5000 |
|    헬스    | 6000 |
|  골프초급  | 8000 |

- 프로그램 테이블에서 헬스 Row에 해당하는 가격 하나만 수정해도 싹 다 변경된다.
- 손흥민은 얼마를 내야해? -> 회원관리 테이블만 보고선 알 수 없다. JOIN 해야 알 수 있다.

### 제 2 정규형의 정확한 정의

- **partial dependency가 무엇이고?**

  - Composite primary key(복합키, primary key 가 없어, 여러개의 key 를 합쳐 만든 key)
  - 가격은 프로그램에 종속적 -> 이 경우에 partial dependency가 있다고 한다.
  - Composite primary key 중에 특정 컬럼에만 종속되는 것을 Partial Dependency가 있다고 하는 것.

### 제 3 정규형 (3NF): 기본키를 제외한 속성들 간의 이행 종속성(Transitive Dependency)이 없어야 한다.

이행 종속성이란 A->B, B->C 일 때, A->C가 성립하면 이행 종속!

| 프로그램 | 가격 |  강사  | 출신대학 |
| :------: | :--: | :----: | :------: |
|  스쿼시  | 5000 | 김을용 |  서울대  |
|   헬스   | 6000 | 박덕팔 |  연세대  |
|   골프   | 8000 | 이상구 |  고려대  |
| 골프중급 | 9000 | 이상구 |  고려대  |
| 개인피티 | 6000 | 박덕팔 |  연세대  |

- 만약에 이상구씨의 학력위조가 밝혀져 알고보니 구라대였다.
- 이것 또한 이상구씨에 해당하는 모든 열을 뒤져 구라대로 바꿔야해..

### 제 3 정규형을 활용

| 프로그램 | 가격 |  강사  |
| :------: | :--: | :----: |
|  스쿼시  | 5000 | 김을용 |
|   헬스   | 6000 | 박덕팔 |
|   골프   | 8000 | 이상구 |
| 골프중급 | 9000 | 이상구 |
| 개인피티 | 6000 | 박덕팔 |

|  강사  | 출신대학 |
| :----: | :------: |
| 김을용 |  서울대  |
| 박덕팔 |  연세대  |
| 이상구 |  고려대  |
| 박덕팔 |  연세대  |

- 출신 대학은 프로그램 테이블의 Primary key(프로그램)와 전혀 상관없다.
- 그저 강사라는 잔챙이 컬럼에만 종속되어 있을 뿐
- 이렇게 잔챙이 컬럼(일반 컬럼)에만 종속된 컬럼을 다른 테이블로 빼는 것이 제 3 정규화!

### BCNF (Boyce-Codd Normal Form) : 제 3 정규형의 강화된 버전

| 회원번호 | 프로그램 |  강사  |
| :------: | :------: | :----: |
|   101    |  스쿼시  | 김을용 |
|   102    |   헬스   | 박덕팔 |
|   103    |   헬스   | 김종국 |
|   103    | 골프초급 | 이상구 |

- 회원 번호, 프로그램이 복합키(기본키)로, 강사를 알 수 있다.
- 같은 과목을 다른 강사가 가르칠 수도 있어서 프로그램 -> 강사 종속은 성립하지 않는다. (제 2정규형 만족)
- 복합키를 제외한 속성에서 이행 종속성 없다! (애초에 복합키 제외하면 속성 한개밖에 없어..) (제 3정규형 만족)
- 강사를 알면 그 강사가 어떤 과목을 가르치는지 알 수 있으므로 강사->과목 종속이 성립!

  - 후보키 집합이 아닌 컬럼이 결정자가 되어버린 상황을 BCNF를 만족하지 않는다고 한다.

    ※결정자 : 어떤 속성의 값이 다른 속성의 값을 고유하게 결정할 수 있음.

| 회원번호 |  강사  |
| :------: | :----: |
|   101    | 김을용 |
|   102    | 박덕팔 |
|   103    | 김종국 |
|   103    | 이상구 |

|  강사  | 프로그램 |
| :----: | :------: |
| 김을용 |  스쿼시  |
| 박덕팔 |   헬스   |
| 김종국 |   헬스   |
| 이상구 | 골프초급 |

- 강사가 기본키로 세팅된 테이블로 분해했다!
- 후보키(강사)가 아닌 컬럼(프로그램)이 결정자가 되지 않았다! -> BCNF 만족

## 제 4 정규형 (4NF)

| 회원번호 | 프로그램 | 동호회 |
| :------: | :------: | :----: |
|   101    |  스쿼시  |  낚시  |
|   102    |   헬스   |  요리  |
|   103    |   헬스   |  낚시  |
|   103    |   헬스   |  요리  |
|   103    | 골프초급 |  낚시  |
|   103    | 골프초급 |  요리  |

- 103번을 주목! 이 회원은 헬스, 골프초급을 수강하고 / 낚시, 요리 동호회에 가입 중이야.
- 이렇게 되면 103번 회원 번호 하나에 프로그램 여러개와 취미 여러개가 종속되어있지.
- 프로그램과 동호회는 관계없는 독립적인 관계지만, 중복이 발생하게 돼!

  회원번호라는 컬럼에 독립적인 관계인 프로그램과 동호회가 다치종속 되어있는 상태.

### 제 4 정규화로 중복을 제거하자

- BCNF를 만족하는 상태
- 3개 이상의 컬럼을 지니는 상황에서 2개 이상의 컬럼이 하나의 컬럼에 다치 종속되지 않아야 한다.

  다치종속?

  - A->B 일 때, 하나의 A값에 여러 개의 B값이 존재하면 다치 종속성을 가진다고 한다.

| 회원번호 | 프로그램 |
| :------: | :------: |
|   101    |  스쿼시  |
|   102    |   헬스   |
|   103    |   헬스   |
|   103    | 골프초급 |

| 회원번호 | 동호회 |
| :------: | :----: |
|   101    |  낚시  |
|   102    |  요리  |
|   103    |  낚시  |
|   103    |  요리  |

- 위 2개의 테이블은 여전히 다치 종속성을 가지지만,
- 하나의 컬럼에 다치 종속되지는 않기 때문에 제 4 정규형을 만족한다!
- 중복이 사라지는 효과를 얻을 수 있었다.

## 제 5 정규형 (5NF)

중복을 제거하기 위해 분해할 수 있을 만큼 전부 분해하는 것!

- 제 4 정규형을 만족하는 상태
- 조인 종속이 없어야한다.
- 조인 연산을 했을 때 손실이 없어야한다. (원상복구 할 수 있도록 분리한 상태)

※조인 종속?

- 다치 종속의 좀 더 일반화된 형태
- 만약 하나의 릴레이션을 여러 개의 릴레이션으로 무손실 분해했다가 다시 결합할 수 있다면 조인 종속이라고 한다.
- 쉽게 말해.. 분해한걸 다시 원상복구 시킬 수 있느냐?

![image](https://user-images.githubusercontent.com/50827930/210026338-e05496d1-2c17-4308-9427-300a61a8647b.png)

### 정규화의 장점

- 데이터베이스 변경 시 이상 현상(Anomaly, Relation(=Table) 처리 과정에서 불필요한 데이터 중복으로 인해 발생하는 부작용) 를 제거할 수 있다.
- 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
- 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되어 응용 프로그램의 생명을 연장시킨다.

### 정규화의 단점

- 릴레이션의 분해로 인해 릴레이션 간의 JOIN 연산이 많아진다.
- Query에 대한 응답 시간이 느려질 수도 있다.

## 3.Transaction

트랜잭션(Transaction 이하 트랜잭션)이란, **데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위**를 뜻한다.
**데이터베이스의 상태를 변화시킨다는 것은 SQL을 이용하여 데이터베이스를 접근 하는 것을 의미한다.**

- SELECT
- INSERT
- DELETE
- UPDATE

오해하지 말아야 할 것은, 작업의 단위는 SQL 한문장이 아니라는 점이다. 게시판을 예로 들어보자. 게시판 사용자는 게시글을 작성하고, 올리기 버튼을 누른다. 그 후에 다시 게시판에 돌아왔을때, 게시판은 자신의 글이 포함된 업데이트된 게시판을 보게 된다.
이러한 상황을 데이터베이스 작업으로 옮기면, 사용자가 올리기 버튼을 눌렀을 시, Insert 문을 사용하여
사용자가 입력한 게시글의 데이터를 옮긴다. 그 후에, 게시판을 구성할 데이터를 다시 Select 하여 최신 정보로
유지한다. 여기서 작업의 단위는 insert문과 select문 둘다 를 합친것이다. 이러한 작업단위를 하나의 트랜잭션이라 한다.

### 트랜잭션의 특성

- 원자성(Atomicity): 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다.
- 일관성(Consistency): 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
- 고립성(Isolation): 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
- 지속성(Durability): 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

### 트랜잭션을 사용할 때 주의할 점

트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉 트랜잭션의 범위를 최소화하라는 의미다. 일반적으로 데이터베이스 커넥션은 개수가 제한적이다. 그런데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 개수는 줄어들게 된다. 그러다 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있는 것이다.

## 4.교착상태

복수의 트랜잭션을 사용하다보면 교착상태가 일어날수 있다. 교착상태란 두 개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데, 이를 `교착상태`라고 한다.

#### 교착상태의 예

데드락이란 둘 이상의 프로세스가 다른 프로세스가 소유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황이다.

![deadlock](/static/database/deadlock.png)

#### 교착 상태의 빈도를 낮추는 방법

- 트랜잭션을 자주 커밋한다.
- 정해진 순서로 테이블에 접근한다. 위에서 트랜잭션 1 이 테이블 B -> A 의 순으로 접근했고,
  트랜잭션 2 는 테이블 A -> B의 순으로 접근했다. 트랜잭션들이 동일한 테이블 순으로 접근하게 한다.
- 읽기 잠금 획득 (SELECT ~ FOR UPDATE)의 사용을 피한다.
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다, 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성은 떨어지지만 교착상태를 회피할 수 있다.

## 5.NoSQL

관계형 데이터 모델을 **지양** 하며 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었으며 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소를 말한다.

### 저장 방식에 따른 NoSQL 분류

`Key-Value Model`, `Document Model`, `Column Model`, `Graph Model`로 분류할 수 있다.

### Key-Value Model

- 가장 기본적인 형태의 NoSQL 이며 키 하나로 데이터 하나를 저장하고 조회할 수 있는 단일 키-값 구조를 갖는다.
- 단순한 저장구조로 인하여 복잡한 조회 연산을 지원하지 않는다. 또한 고속 읽기와 쓰기에 최적화된 경우가 많다.
- 사용자의 프로필 정보, 웹 서버 클러스터를 위한 세션 정보, 장바구니 정보, URL 단축 정보 저장 등에 사용한다.
- 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 데이터 정합성을 보장할 수 없다.
- _ex) Redis_

### Document Model

- 키-값 모델을 개념적으로 확장한 구조로 하나의 키에 하나의 구조화된 문서를 저장하고 조회한다.
- 논리적인 데이터 저장과 조회 방법이 관계형 데이터베이스와 유사하다. 키는 문서에 대한 ID 로 표현된다.
- 또한 저장된 문서를 컬렉션으로 관리하며 문서 저장과 동시에 문서 ID 에 대한 인덱스를 생성한다.
- 문서 ID 에 대한 인덱스를 사용하여 O(1) 시간 안에 문서를 조회할 수 있다.
- _ex) MongoDB_

### Column Model

- 하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다. 모든 컬럼은 항상 타임 스탬프 값과 함께 저장된다.

- 구글의 빅테이블이 대표적인 예로 차후 컬럼형 NoSQL 은 빅테이블의 영향을 받았다.
- 이러한 이유로 Row key, Column Key, Column Family 같은 빅테이블 개념이 공통적으로 사용된다.
- 저장의 기본 단위는 컬럼으로 컬럼은 컬럼 이름과 컬럼 값, 타임스탬프로 구성된다.
- 이러한 컬럼들의 집합이 로우(Row)이며, 로우키(Row key)는 각 로우를 유일하게 식별하는 값이다. 이러한 로우들의 집합은 키 스페이스(Key Space)가 된다.

- 대부분의 컬럼 모델 NoSQL 은 쓰기와 읽기 중에 쓰기에 더 특화되어 있다.
- 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공한다.
- 그렇기 때문에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다. 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적합하다.

## 6.SQL Injection

**SQL인젝션은 웹 사이트의 보안상 허점을 이용해 특정 SQL 쿼리 문을 전송하여 공격자가 원하는 DB의 중요한 정보를 가져오는 해킹기법이다.** 대부분 클라이언트가 입력한 데이터를 제대로 필터링하지 못하는 경우에 발생한다. 공격 난이도가 쉽고 피해 규모가 상당하기 때문에 보안 위협 1순위로 불릴 만큼 중요한 기법이다.

## 7.키(Key)

키는 데이터베이스에서 조건에 만족하는 관계의 행을 찾거나 순서대로 정렬할 때 다른 행과 구별할 수 있는 유리한 기준이 되는 속성의 집합이다.

### 유일성

하나의 키로 특정 행을 바로 찾아낼수 있는 고유한 데이터 속성을 말한다. 예를 들면 주민번호는 전국민이 모두 겹치지 않아 유일하고 고유한 구별 방법으로 쓰인다.

### 최소성

키를 구성하는 속성들 중 가장 최소로 필요한 속성들로만 키를 구성하는 성질을 말한다.

### 슈퍼 키(super key)

테이블에서 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합이다. 슈퍼키는 유일성만 만족하면 슈퍼키가 될 수 있다.

![super-key](/static/database/super-key.png)

### 후보 키(candidate key)

테이블에서 각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합이다. 후보키는 기본키가 될 수 있는 후보들이며 유일성과 최소성을 동시에 만족해야한다.

![candidate-key](/static/database/candidate-key.png)

### 기본 키(primary key)

- 후보키들 중에서 하나를 선택한 키로 **최소성과 유일성을 만족하는 속성이다.**
- 테이블에서 기본키는 오직 1개만 지정할 수 있다.
- 기본키는 테이블 안에서 유일하게 각 행들을 구별할 수 있도록 쓰인다.
- 기본키는 NULL 값을 절대 가질수 없고, 중복된 값을 가질 수 없다.
- 각 행들을 구별하려면 값이 없어선 안되고, 중복되어서도 안되기 때문이다.
- ex.) uuid

![primary-key](/static/database/primary-key.png)

## 8.SQL JOIN

아래의 링크로 대체합니다.

### https://sql-joins.leopard.in.ua/

## 9.SQL Basicc

아래의 링크로 대체합니다.

### https://s3.amazonaws.com/assets.datacamp.com/email/other/SQL+for+Data+Science.pdf

## reference

- [Tech Interview Cheat Sheet](https://github.com/da-in/tech-interview-study/tree/main/Tech%20Interview%20Cheat%20Sheet/Database)

- [Transaction]https://mommoo.tistory.com/62
